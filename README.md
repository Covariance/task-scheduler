# JB scheduler

## Задача
Требуется реализовать простой планировщик задач. На вход данному планировщику передается набор задач, которые он должен выполнить.
Задача может обладать зависимостями, то есть набором задач, которые требуется выполнить до выполнения данной.

Задача представляется интерфейсом:
```java
interface Task {
  // выполняет задачу
  void execute();

  // возвращает зависимости для данной задачи
  Collection<Task> dependencies();
}
```
Требуется написать исходный код класса, реализующего планировщик:

```java
class TaskExecutor {
  void execute(Collection<Task> tasks) {
    // реализация
  }
}
```
Вы можете делать дополнительные предположения, которые вам кажутся необходимыми. Большим плюсом будет, если планировщик будет многопоточным. Данный планировщик должен быть устойчив к некорректным входным данным.

## Реализация

Для начала, я позволил себе немного вольностей, и заменил сигнатуру метода `execute` в классе `TaskExecutor`
на следующую:

```java
class TaskExecutor {
  void execute(Collection<? extends Task> tasks) {
    // реализация
  }
}
```

Аналогично заменен метод `dependencies` в интерфейсе `Task`:

```java
public interface Task {
  void execute();

  Collection<? extends Task> dependencies();
}
```

Потому что так гораздо удобнее, а функционал только расширяется.

`TaskExecutor` создаёт экземпляр класса `ExecutionController`, который, как следует из названия,
контролирует дальнейшее исполнение. Там создаётся `DependencyTree`, которое в свою очередь 
строит транзитивное замыкание множества задач (таким образом обрабатываются задачи, которые являются
зависимостями, но не входят в изначальный набор). `null`-значения игнорируются.

После построения дерева зависимостей создаётся `ForkJoinPool`, механизм которого и управляет
конкурентным исполнением. Новые задачи становятся доступны для исполнения когда все их зависимости выполнены,
и в этот момент `ExecutionController` отдаёт их в `ForkJoinPool`.

## Кто-то сказал тесты?

Они есть! Хотя они довольно базовые, но даже их базовый функционал покрывает достаточно большое
количество ошибок. Все они лежат [вот тут](./src/test/java).

На всех тестах стоят аннотации таймаута, потому что плохие конкурентные программы имеют 
неприятное свойство попадать в deadlock, и в таких ситуациях тесты без таймаута просто виснут.

## А как мне это проверить?

Проект собирается при помощи **Apache Maven**. Я не стал класть исполнимые файлы **Maven**-а
в репозиторий, так что его необходимо будет [установить](https://maven.apache.org/install.html).

Прогнать решение на тестах можно с помощью **Maven Surefire Plugin**:
```shell
mvn test --file pom.xml
```

Проверить на соответствие Google Code Style можно с помощью **Checkstyle Plugin**:
```shell
mvn checkstyle:check --file pom.xml
```

Кроме того, решение модуляризовано, что позволяет легко использовать его в современных java-проектах.
