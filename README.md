# JB scheduler

## Задача
Требуется реализовать простой планировщик задач. На вход данному планировщику передается набор задач, которые он должен выполнить.
Задача может обладать зависимостями, то есть набором задач, которые требуется выполнить до выполнения данной.

Задача представляется интерфейсом:
```java
interface Task {
  // выполняет задачу
  void execute();

  // возвращает зависимости для данной задачи
  Collection<Task> dependencies();
}
```
Требуется написать исходный код класса, реализующего планировщик:

```java
class TaskExecutor {
  void execute(Collection<Task> tasks) {
    // реализация
  }
}
```
Вы можете делать дополнительные предположения, которые вам кажутся необходимыми. Большим плюсом будет, если планировщик будет многопоточным. Данный планировщик должен быть устойчив к некорректным входным данным.

## Реализация

Для начала, я позволил себе немного вольностей, и заменил сигнатуру метода `execute` в классе `TaskExecutor`
на следующую:

```java
class TaskExecutor {
  void execute(Collection<? extends Task> tasks) {
    // реализация
  }
}
```

Аналогично заменен метод `dependencies` в интерфейсе `Task`:

```java
public interface Task {
  void execute();

  Collection<? extends Task> dependencies();
}
```

Потому что так гораздо удобнее, а функционал только расширяется.

`TaskExecutor` создаёт экземпляр класса `ExecutionController`, который, как следует из названия,
контролирует дальнейшее исполнение. Там создаётся `DependencyTree`, которое в свою очередь 
строит транзитивное замыкание множества задач (таким образом обрабатываются задачи, которые являются
зависимостями, но не входят в изначальный набор). `null`-значения игнорируются.

После построения дерева зависимостей создаётся `ForkJoinPool`, механизм которого и управляет
конкурентным исполнением. Новые задачи становятся доступны для исполнения когда все их зависимости выполнены,
и в этот момент `ExecutionController` отдаёт их в `ForkJoinPool`.